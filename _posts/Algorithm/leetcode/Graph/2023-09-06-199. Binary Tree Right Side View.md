---
layout: single
title: "[199. Binary Tree Right Side View] (ì•Œê³ ë¦¬ì¦˜)"
categories: Algo
tags:
  - leetcode
  - Python
  - BFS
toc: true
toc_sticky: true
author_profile: false
sidebar:
---
`BFS`
## ë¬¸ì œ


[ë¬¸ì œ ë§í¬](https://leetcode.com/problems/binary-tree-right-side-view/?envType=study-plan-v2&envId=top-interview-150)

Given theÂ `root`Â of a binary tree, imagine yourself standing on theÂ **right side**Â of it, returnÂ _the values of the nodes you can see ordered from top to bottom_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/14/tree.jpg)

**Input:** root = [1,2,3,null,5,null,4]
**Output:** [1,3,4]

**Example 2:**

**Input:** root = [1,null,3]
**Output:** [1,3]

**Example 3:**

**Input:** root = []
**Output:** []

**Constraints:**

- The number of nodes in the tree is in the rangeÂ `[0, 100]`.
- `-100 <= Node.val <= 100`

## ìŠ¤ìŠ¤ë¡œ ê³ ë¯¼

- ì´ì „ì— ì‚¬ìš©í–ˆë˜ ë°©ë²•ì„ ë³µìŠµí•˜ê³  while ë¬¸ìœ¼ë¡œ ë‹¤ì‹œ êµ¬í˜„í•´ë³´ë ¤ê³  í–ˆë‹¤.
- ê·¼ë° 2ê°œë§Œ ë“¤ì–´ìˆì„ ê²½ìš° ì˜¤ë¥¸ìª½ë§Œ ë°˜í™˜ë˜ì–´ì„œ ë¬¸ì œë¥¼ í†µê³¼í•˜ì§€ ëª» í–ˆë‹¤.
- ì˜ˆë¥¼ ë“¤ì–´ `[1,2]` ë§Œ ìˆì„ ê²½ìš° ì‹¤ì œë¡œëŠ” root ê°€ 1 ì™¼ìª½ì— 2ê°€ ë“¤ì–´ê°€ê¸° ë•Œë¬¸ì— 1ë§Œ ë°˜í™˜í•˜ê²Œ ë˜ëŠ”ë° ì‹¤ì œë¡œëŠ” 2ê°œ ë°–ì— ì—†ìœ¼ë‹ˆ 1ê³¼ 2 ëª¨ë‘ë¥¼ ë¦¬í„´í•´ì•¼ ë˜ëŠ” ìƒí™©ì´ë‹¤.
- ì„ì‹œ ë°©í¸ìœ¼ë¡œ í•´ë‹¹ ì¼€ì´ìŠ¤ë§Œ í†µê³¼í•˜ë„ë¡ ì•„ë˜ì™€ ê°™ì´ ë§Œë“¤ì—ˆë‹¤

```python
Â  Â  Â  Â  if root is not None and root.right is None and root.left is not None and root.left.left is None and root.left.right is None:

Â  Â  Â  Â  Â  Â  return [root.val] + [root.left.val]
```

- í•˜ì§€ë§Œ `[1,2,3,4]` ì¼ ê²½ìš°ì— 3ë²ˆ íŠ¸ë¦¬ì—ì„œ ì™¼ìª½ìœ¼ë¡œ 4ê°€ ë“¤ì–´ê°ˆ ê²½ìš°ì—ë„ ë…¸ë“œê°€ 1ê°œë§ˆ ìˆìœ¼ë‹ˆ ê·¸ëƒ¥ ì™¼ìª½ìœ¼ë¡œ ì³ì£¼ëŠ” ê²ƒ ê°™ì•˜ë‹¤.
- ê¸°ì¡´ì— ì‚¬ìš©í–ˆë˜ íŒ¨í„´ê³¼ëŠ” ë‹¤ë¥´ê²Œ ë…¸ë“œê°€ 2ê°œì¸ì§€ 1ê°œì¸ì§€ë¥¼ ì¶”ê°€í•´ì•¼ í†µê³¼í•  ìˆ˜ ìˆë‹¤ê³  ìƒê°í–ˆë‹¤.

```python
class Solution:

Â  Â  def rightSideView(self, root: Optional[TreeNode]) -> List[int]:

Â  Â  Â  Â  answer = []

Â  Â  Â  Â  head = root

Â  Â  Â  Â  while head:

Â  Â  Â  Â  Â  Â  if head.left is not None and head.right is not None:

Â  Â  Â  Â  Â  Â  Â  Â  answer.append(head.val)

Â  Â  Â  Â  Â  Â  Â  Â  head = head.right

Â  Â  Â  Â  Â  Â  elif head.left is not None and head.right is None:

Â  Â  Â  Â  Â  Â  Â  Â  answer.append(head.val)

Â  Â  Â  Â  Â  Â  Â  Â  head = head.left

Â  Â  Â  Â  Â  Â  elif head.left is None and head.right is not None:

Â  Â  Â  Â  Â  Â  Â  Â  answer.append(head.val)

Â  Â  Â  Â  Â  Â  Â  Â  head = head.right

Â  Â  Â  Â  Â  Â  else:

Â  Â  Â  Â  Â  Â  Â  Â  answer.append(head.val)

Â  Â  Â  Â  Â  Â  Â  Â  head = []

Â  Â  Â  Â  return answer
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.right.right = TreeNode(4) or root.right.left = TreeNode(4)
```

- ë¡œì»¬ì—ì„œëŠ” ì´ë ‡ê²Œ ë¬¸ì œë¥¼ í’€ì—ˆì„ ë•Œ ë‹µì´  `[1,3,4]` ê°€ ì˜ ë‚˜ì™”ëŠ”ë° ë¦¬íŠ¸ì½”ë“œ ì‚¬ì´íŠ¸ì—ì„œëŠ” ì—¬ì „íˆ `[1.3]` ë§Œ ë‚˜ì™€ì„œ ì´í•´ê°€ ì•ˆê°”ë‹¤.

![](https://assets.leetcode.com/users/images/cef92daf-88dd-46b5-a329-b179916c6482_1618278364.1240458.png)

- ì´í•´ê°€ ê°€ì§€ ì•Šì•„ì„œ í•´ë‹¹ ë¬¸ì œì˜ Discussion ì„ í™•ì¸í•´ë´¤ëŠ”ë° ë‹¨ìˆœíˆ ì˜¤ë¥¸ìª½ì´ ì•„ë‹ˆë¼ ì˜¤ë¥¸ìª½ì—ì„œ ë°”ë¼ë´¤ì„ ë•Œ ë³´ì´ëŠ” ëª¨ë“  ë…¸ë“œì˜ ê°’ì„ ë°˜í™˜í•´ì•¼ë˜ëŠ” ê±°ì˜€ë‹¤ ğŸ˜‘

- ìœ„ì™€ ê°™ì€ í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ê°€ ë‚˜ì˜¬ ê²½ìš° ì–´ì°¨í”¼ í†µê³¼ë¥¼ ëª» í•œë‹¤.

### í•´ê²°ì±…

- ìˆ˜ì—…ì‹œê°„ì— ë°°ìš´ BFS í˜¹ì€ DFSë¥¼ ì‚¬ìš©í•´ì•¼ í•´ê²°ì´ ê°€ëŠ¥í•´ ë³´ì˜€ë‹¤.
- ê·¸ë ‡ê²Œ ìƒê°í•œ ì´ìœ ëŠ” ê° ì¸µì„ ë‹¤ ì°¾ì•„ë³´ë©´ì„œ ì˜¤ë¥¸ìª½ì—ì„œ ê°€ì¥ ë¨¼ì € ë‚˜ì˜¤ëŠ” ë…¸ë“œë¥¼ ì°¾ì•„ì•¼ í•˜ê¸° ë•Œë¬¸ì´ë‹¤.
- ê·¼ë° ê° ì¸µë§ˆë‹¤ ì˜¤ë¥¸ìª½ ê°’ì„ ê°–ê³  ì™€ì•¼í•˜ë‹ˆ BFSê°€ ë” ì˜ ë§ê² ë‹¤ê³  ìƒê°í–ˆë‹¤.

```python
   1
  / \
 2   3
  \   \
   5   4

```

1ì´ ìˆëŠ” ì¸µì—ì„œëŠ” 1     
ìœ„ì— ì²˜ëŸ¼ 2, 3 ì´ ìˆëŠ” ì¸µì—ì„œëŠ” 3     
5,4 ê°€ ìˆëŠ” ì¸µì—ì„œëŠ” 4      
`[1,3,4]` ì´ëŸ° ì‹ìœ¼ë¡œ ë‚˜ì™€ì•¼ ëœë‹¤.

## ì˜ì‚¬ì½”ë“œ

- BFS ë¥¼ êµ¬í˜„í•˜ê¸° ìœ„í•´ì„œëŠ” collections ëª¨ë“ˆì˜ dequeë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
- dequeëŠ” íì™€ ìŠ¤í…ì˜ íŠ¹ì§•ì„ ëª¨ë‘ ê°–ê³  ìˆëŠ”ê²Œ íŠ¹ì§•ì´ë‹¤.
- ìš°ì„  root ê°€ ë¹ˆ ê°’ì¸ì§€ í™•ì¸í•˜ê³  ë¹ˆ ê°’ì´ë¼ë©´ ë¹ˆ ê°’ì„ ë¦¬í„´í•´ì£¼ë©´ì„œ ëë‚´ì¤€ë‹¤.
- ë¹ˆ ê°’ì´ ì•„ë‹ˆë¼ë©´ result ì˜ ë¹ˆ ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ì¤€ë‹¤.
- queue ë¥¼ ì„ ì–¸í•˜ê³  dequeì— rootë¥¼ ë„£ì–´ì¤€ë‹¤.
- while ë¬¸ì„ í†µí•´ queue ì˜ ê°’ì´ ì—†ì„ ë•Œ ê¹Œì§€ ì‹¤í–‰ì‹œì¼œì¤€ë‹¤.
- ê° ì¸µì„ í™•ì¸í•˜ê¸° ìœ„í•´ì„œ floor ë¥¼ ì„ ì–¸í•´ì£¼ê³  len(queue)ë¥¼ ë‹´ì•„ì¤€ë‹¤.
  ì´ë ‡ê²Œ í•˜ë©´ ê° ì¸µì— ìˆëŠ” queue ì˜ ê°¯ìˆ˜ë¥¼ ì•Œ ìˆ˜ ìˆë‹¤.
- ê° ì¸µì— íê°€ ìˆëŠ” ê°¯ìˆ˜ ë§Œí¼ ë°˜ë³µë¬¸ì„ ì‹¤í–‰ì‹œí‚¨ë‹¤.
- í˜„ì¬ ì¸µì—ì„œ í•´ë‹¹ ê°’ì´ ê°€ì¥ ë§ˆì§€ë§‰ì¸ì§€ í™•ì¸í•œ í›„ ë§ˆì§€ë§‰ ê°’ì´ë¼ë©´ í•´ë‹¹ ê°’ì„ resultì— ë„£ì–´ì¤€ë‹¤. 
- ì´ë ‡ê²Œ í•˜ëŠ” ì´ìœ ëŠ” ì™¼ìª½ë¶€ë¶„ì„ íë¡œ ë½‘ê³  ë‹¤ìŒ ìˆœìœ¼ë¡œ ì˜¤ë¥¸ìª½ ë¶€ë¶„ì„ íë¡œ ë½‘ê¸° ë•Œë¬¸ì— ë§Œì•½ì— ì™¼ìª½ ì˜¤ë¥¸ìª½ ë‘˜ ë‹¤ ìˆì„ ê²½ìš° len(queue)ì˜ ê°’ì€ 2ê°œê°€ ë˜ê³  ì™¼ìª½ì´ë‚˜ ì˜¤ë¥¸ìª½ í•˜ë‚˜ë§Œ ë‚¨ì•„ ìˆì„ ê²½ìš°ëŠ” len(queue) ì˜ ê°’ì€ 1ì´ ëœë‹¤. 
- ê°’ì´ 1ì´ ë  ê²½ìš° if ë¬¸ì—ì„œ ë§ˆì§€ë§‰ ê°’ì´ë‹ˆ resultì— ë‹´ê¸´ë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë§ˆì§€ë§‰ ì¸µì˜ ê°’ì´ ì˜¤ë¥¸ìª½ì— ìˆë“  ì™¼ìª½ì— ìˆë“  ë…¸ë“œê°€ í•˜ë‚˜ë§Œ ìˆì„ ê²½ìš° resultì— ë‹´ê²¨ì§€ê³  ë…¸ë“œê°€ ë‘ ê°œ ì¼ ê²½ìš°ì—ëŠ” ì˜¤ë¥¸ìª½ì´ ìë™ìœ¼ë¡œ ë‹´ê¸°ê²Œ ëœë‹¤.

## êµ¬í˜„ ì½”ë“œ

```python
from collections import deque
class Solution:
    def getMinimumDifference(self, root):
        if not root:
            return []

        result = []
        queue = deque([root])

        while queue:
            floor = len(queue)
            for i in range(floor):
                node = queue.popleft()
                print(node.val)
                if i == floor - 1:
                    result.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)

        return result
# BSTë¥¼ ë§Œë“¤ê¸° ìœ„í•´ TreeNode ê°ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ íŠ¸ë¦¬ ìƒì„±
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
root.right.left = TreeNode(4)
```

## ì‹œê°„ ë³µì¡ë„ì™€ ê³µê°„ ë³µì¡ë„

- ì‹œê°„ ë³µì¡ë„: ì½”ë“œëŠ” ì£¼ì–´ì§„ ì´ì§„ íŠ¸ë¦¬ë¥¼ BFS ë°©ì‹ìœ¼ë¡œ íƒìƒ‰í•œë‹¤. ê° ë…¸ë“œëŠ” í•œ ë²ˆë§Œ ë°©ë¬¸ë˜ë¯€ë¡œ ì‹œê°„ ë³µì¡ë„ëŠ” O(N) ë‹¤. ì—¬ê¸°ì„œ Nì€ ì´ì§„ íŠ¸ë¦¬ì˜ ë…¸ë“œ ìˆ˜ë‹¤.
    
- ê³µê°„ ë³µì¡ë„: íë¥¼ ì‚¬ìš©í•˜ì—¬ ë…¸ë“œë¥¼ ì €ì¥í•˜ë¯€ë¡œ ê³µê°„ ë³µì¡ë„ëŠ” íì˜ í¬ê¸°ì— ë”°ë¼ ê²°ì •ëœë‹¤. ê° ë ˆë²¨ì—ì„œ ë…¸ë“œ ìˆ˜ë§Œí¼ íì— ì €ì¥ë˜ë¯€ë¡œ ìµœì•…ì˜ ê²½ìš° ì´ì§„ íŠ¸ë¦¬ì˜ ë§ˆì§€ë§‰ ë ˆë²¨ì— ìˆëŠ” ëª¨ë“  ë…¸ë“œê°€ íì— ì €ì¥ë  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ ê³µê°„ ë³µì¡ë„ëŠ” O(2^h)ê°€ ëœë‹¤. ì—¬ê¸°ì„œ hëŠ” ì´ì§„ íŠ¸ë¦¬ì˜ ë†’ì´ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.

## íšŒê³  ê³¼ì •

- ë¬¸ì œë¥¼ í’€ë©´ì„œ BFSì— ëŒ€í•´ì„œ ì¡°ê¸ˆ ì´í•´í•œ ê²ƒ ê°™ë‹¤. ë¬¸ì œë¥¼ ì¢€ ë” í’€ì–´ë´ì•¼ ìì‹ ê°ì´ ìƒê¸¸ ê²ƒ ê°™ë‹¤.

### ë‹¤ë¥¸ ì‚¬ëŒ ì½”ë“œë¥¼ ë³´ê³  ê·¸ ê¸°ì¤€ìœ¼ë¡œ ì–´ë–¤ ë¶€ë¶„ì„ ê°œì„  í•  ìˆ˜ ìˆëŠ”ì§€ ìµœì¢… íšŒê³ 

```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        res = []

        def helper(node, level):
            if node is None:
                return
            if level == len(res):
                res.append(node.val)
            helper(node.right, level + 1)
            helper(node.left, level + 1)
        
        helper(root, 0)
        return res
```

- deque ì‚¬ìš© ì—†ì´ ë¬¸ì œë¥¼ í•´ê²°í•œ ì¼€ì´ìŠ¤ë‹¤.
- Nodeê°€ noneì´ ì•„ë‹ˆë¼ë©´ root ë…¸ë“œë¥¼ 0ë²ˆìœ¼ë¡œ ì‹œì‘í•´ì„œ í˜„ì¬ ì¸µì—ì„œ ë§ˆì§€ë§‰ ë…¸ë“œì¸ì§€ë¥¼ len í•¨ìˆ˜ë¥¼ í™•ì¸í•´ì„œ node ê°’ì„ ë„£ê³  ê·¸ê²Œ ì•„ë‹ˆë¼ë©´ ì¬ê·€í˜¸ì¶œë¡œ ë¬¸ì œë¥¼ í•´ê²°í•œ ë°©ì‹ì´ë‹¤.
- ì´ë ‡ê²Œ ìƒê°ì„ ëª» í•´ì„œ ì•„ì‰½ê¸°ë„ í•˜ì§€ë§Œ deque ë¥¼ ì•Œê²Œë˜ì–´ì„œ ì¢‹ì€ ì ë„ ìˆì—ˆë‹¤.