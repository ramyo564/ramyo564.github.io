---
layout: single
title: "DFS와 BFS 그래프 탐색(알고리즘)"
categories: Algo
tag: ["백준","Python","1260문제"]
toc: true
toc_sticky: true
author_profile: false
sidebar:

---
# 자료구조

## 스택 자료구조
선입후출 -> 프링글스 과자통을 생각하자 -> 들어온 순서가 1,2,3,4,5 면 나갈 때는 5,4,3,2,1
이런 식이다.    
파이썬에서는 list를 이용하면 되고 append 와 pop을 사용하면 된다.
시간복잡도는 O(1)
최상단 원소부터 출력은 `list[::-1]`

### 슬라이싱

```python
my_list = [1, 2, 3, 4, 5]

# 리스트의 1번째부터 3번째 인덱스 직전까지의 요소를 선택합니다.
result1 = my_list[1:3]  # 출력: [2, 3]

# 리스트의 처음부터 3번째 인덱스 직전까지의 요소를 선택합니다.
result2 = my_list[:3]  # 출력: [1, 2, 3]

# 리스트의 2번째부터 끝까지의 요소를 선택합니다.
result3 = my_list[2:]  # 출력: [3, 4, 5]

# 리스트의 처음부터 끝까지 요소를 모두 선택합니다. (스텝은 기본값 1로 인접한 요소들만 선택)
result4 = my_list[:]  # 출력: [1, 2, 3, 4, 5]

# 리스트의 처음부터 끝까지의 요소를 역순으로 선택합니다. (스텝 -1 사용)
result5 = my_list[::-1]  # 출력: [5, 4, 3, 2, 1]

# 리스트의 두 칸씩 건너뛰며 요소를 선택합니다.
result6 = my_list[::2]  # 출력: [1, 3, 5]


my_list = [1, 2, 3, 4, 5] result = my_list[:-1] 
print(result) # 출력: [1, 2, 3, 4]
```

## 큐 자료구조

입구와 출구가 모두 뚫려 있는 터널을 생각하면됨     
1,2,3,4,5 로 들어가면 1,2,3,4,5 로 나옴     

파이썬에서 시간복잡도 때문에 deque 라이브러리를 사용 -> 시간 복잡도는 0(1)

```python
from collections import deque
queue = deque()
queue.append(1)
queue.append(2)
queue.append(3)
queue.popleft()
queue.append(4)
queue.popleft()
queue.append(5)

--> 3,4,5
# 거꾸로 뒤집을 때는
queue.reverse()
--> 5,4,3

```

