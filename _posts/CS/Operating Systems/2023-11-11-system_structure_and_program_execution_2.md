---
layout: single
title: " [운영체제] 시스템 구조(2)"
categories: CS
tags:
  - CS
  - OperatingSystems
toc: true
toc_sticky: true
author_profile: false
sidebar:
---
# 동기식 입출력과 비동기식 입출력

- 동기식 입출력 (synchronous I/O)
	- I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
	- 구현 방법 1
		- I/O가 끝날 때까지 CPU를 낭비시킴
		- 매시점 하나의 I/O만 일어날 수 있음
	- 구현 방법 2
		- I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
		- I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
		- 다른 프로그램에게 CPU를 줌
- 비동기식 입출력 (asynchronous I/O)
	- I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

- 두 경우 모두 I/O의 완료는 인터럽트로 알려줌

![](https://i.imgur.com/qMTqjuC.png)

## DMA(Direct Memory Access)

![](https://i.imgur.com/w714XxJ.png)


CPU는 메모리에 올라와 있는 기계어를 계속 실행함 -> 레지스터에 메모리 주소를 가리키는 애가 있음 그걸 통해서 인스트럭션을 읽어옴 실행 후 다음 명령을 실행하기 위해 다음 메모리 주소를 갖고 오면서 계속 메모리에 있는 인스트럭션을 순차적으로 실행 -> 하지만 함수 호출이나 if문등의 상황에서 점프를 하는데 점프를 하는 인스트럭션이 따로 있음 이런 경우 때문에 메모리에 있는 인스트럭션을 꼭 순차적으로 실행하는건 아님      

아무튼 현재 인스트럭션이 끝나고 다음 인스트럭션을 진행하기 전에 인터룹트 라인을 확인함 ->이 때 인터룹트에 뭔가 들어와있으면 해당 작업을 멈추고 인터룹트 작업을 실행함 (cpu 제어권이 운영체재한테로 감 -> 운영체제는 매 인터럽트 마다 커널함수로 정의 되어있음 (인터럽트 백터 -> 해당 인터럽트의 처리 루틴 주소를 가지고 있음))

사용자 프로그램이 i/o 작업을 해야할 경우 본인이 직접 못하기 때문에 운영체제한테 요청함 (시스템콜)

원래는 메모리에 접근할 수 있는 장치가 CPU밖에 없음 근데 예를 들어서 키보드 타자 하나의 하나의 요청을 보낼 때마다 인터럽트 요청을해서 CPU가 방해를 너무 많이 당함 (디바이스 컨트롤러가 인터럽트를 걸어놓음)-> 그래서 DMA도 메모리에 직접 접근이 가능함 (DMA가 대신 메모리에 카피하고 어느정도가 넘어가면 그 때 CPU에게 일 끝났다고 인터룹트를 걸음)
-> CPU를 좀 더 효율적으로 사용 가능해짐    

- DMA (Direct Memory Access)
	- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
	- CPU의 중재 없이 device controller가 device 의 buffer storage의 내용을 메모리에 block단위로 직접 전송
	- 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴

![](https://i.imgur.com/eCz67bS.png)

## 서로 다른 입출력 명령어

- I/O 를 수행하는 special instruction 에 의해 (좌) ->일반적인 I/O
- Memory Mapped I/O에 의해 (우)


![](https://i.imgur.com/dc0Hf8r.png)


## 저장장치 계층 구조 

![](https://i.imgur.com/826azxH.png)

- 최상단이 CPU ->아래에서 위로 갈수록 빠르고 비싸고 용량이 적다.
- Secondary는 비휘발성 Primary는 휘발성 -> 전원 꺼지면 정보가 다 날라감
- Secondary 는 바이트 단위가 아닌 섹터 단위로 접근 (CPU가 직접 접근을 못 함 (바이트 단위로 접근이 가능해야함))
- 하드디스크에 있는걸 전부 위로 올릴 수 없음 -> 속도 차이가 많이 나기 때문에 캐시메모리에 올려서 씀 (캐싱 -> 재사용을 위해 사용)

## 프로그램의 실행 (메모리 load)

![](https://i.imgur.com/GRYLYS4.png)

- 프로그램을 실행시키게 되면 그 프로그램의 메모리 주소공간이 생성됨 -> A,B 
- 코드는 CPU에서 실행될 코드고 data는 변수 stack은 함수형태로 호출
- 물리적인 메모리에 올림 -> 종료되면 메모리에서 삭제 -> 당장 필요한 것만 메모리에 올려줌
- 당장 필요하지 않을 경우 swap area에 내려와 있음 스웹 부분은 전원이 끊기면 다 날라감
- 가상메모리에서 실제 메모리에 올라갈 때 주소변환이 필요함


## 커널 주소 공간의 내용

![](https://i.imgur.com/NF0LjMI.png)

- 시스템 안에 프로그램이 하나가 돌아가면 그 프로그램을 관리하기 위한 자료구조가 운영체제 커널에 만들어지는데 그게 PCB -> 프로세스마다 하나의 PCB가 생성됨


## 사용자 프로그램이 사용하는 함수

- 함수 
	- 사용자 정의 함수
		- 자신의 프로그램에서 정의한 함수
	- 라이브러리 함수
		- 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
		- 자신의 프로그램의 실행 파일에 포함되어 있다.
	- 커널 함수
		- 운영체제 프로그램의 함수
		- 커널 함수의 호출 = 시스템 콜

![](https://i.imgur.com/hA4m4uq.png)

## 프로그램의 실행

![](https://i.imgur.com/RkpPbL9.png)



[출처 링크](https://core.ewha.ac.kr/publicview/C0101020140314151238067290?vmode=f)