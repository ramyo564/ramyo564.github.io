---
layout: single
title: " [CS 퀴즈] 오답노트 (3)"
categories: CS
tags:
  - CS
  - CS퀴즈
toc: true
toc_sticky: true
author_profile: false
sidebar:
---
# CS 퀴즈 (3)
## 운영체제 - 프로세스


### **프로세스(Process)**

프로세스는 **실행 중인 프로그램**을 의미한다. 프로세스는 운영체제에 의해 관리되며, 독립적으로 실행되고 자원을 할당 받을 수 있는 단위이다. 운영체제는 프로세스들에게 적절히 자원들을 분배하여 여러가지 작업을 수행할 수 있게 한다.    

프로세스에 대해서 예를 들어보자.    

본인은 엑셀 프로그램(excel.exe)을 켰다. 이때 엑셀을 실행시키기 위해 컴퓨터는 엑셀 프로그램을 읽어야 한다. 컴퓨터에서 모든 프로그램은 코드로 작성되어 있다. 이 코드 파일을 컴퓨터가 읽으려면 CPU가 이해할 수 있는 형태인 저급 언어(0과 1로 이루어진 기계어)로 프로그램이 만들어져야 한다. **0과 1로 작성된 실행 프로그램을 코드 이미지 또는 바이너리** 라고 부르며, 보통 exe란 확장자가 붙는다. 이 exe 프로그램을 실행하면 메모리에 실행할 데이터가 올라가고, CPU가 이 데이터의 코드를 한 줄 씩 읽어 나가며 실행한다. 이때, **메모리에 올려진 데이터를 프로세스**라고 한다.     

---

### **프로세스 구조**

프로세스를 실행시키기 위해서는 코드의 데이터를 메모리에 올려 실행시켜야 한다. 이때, 프로세스마다 고유한 가상 메모리 공간을 제공하며, 이 공간은 4개로 나눌 수 있다.     

![](https://blog.kakaocdn.net/dn/cwDb8r/btsjAwUVeqo/iUj7t2wypnkSL1kmHTwbFK/img.png)

**① code 영역(Text Segment)**     

**-** 내가 작성한 **코드가 저장되는 공간**으로, 코드는 컴파일 되어 0과 1로 변환된 기계어가 저장된다.    

**② Data 영역(Data Segment)**  

**-** 내가 작성한 코드에서 선언된 **전역 변수, 정적 변수, 상수 등을 저장**한다.  

**-** 초기화된 변수와 초기화되지 않은 변수들이 나눠서 저장된다.  

**-** 데이터 영역은 프로그램의 시작 시 초기화되며, 프로세스가 종료될 때까지 유지된다.  

**③ Stack**   

**-** 내가 작성한 함수에서 **지역변수, 매개변수, return 주소들을 저장**한다.  

**-** 알고리즘에서 사용하는 stack 구조를 사용해서 stack이라고 부른다. 프로세스마다 독립적인 stack을 가질 수 있고, stack 포인터를 통해 스택의 상태를 관리한다.    

**-** 함수가 호출되면 stack 공간이 생성되며, 함수가 종료되면 제거된다.   

**④ Heap**   

**-** 내가 작성한 코드에서 **동적으로 생성되는 데이터 구조나 객체들을 저장**한다.   

**-** 예를 들면, 객체나 배열을 생성했을 때 프로그램 실행마다 얼마만큼의 데이터가 추가될 지 모른다. 데이터가 추가됨에 따라 유동적으로 공간을 늘릴 수 있는게 힙 영역이다.   

**-** 힙은 동적으로 할당되는 메모리 영역으로, 프로세스가 실행 중에 동적으로 메모리를 할당받고 해제하는데 사용된다.   

**-** 힙은 프로세스의 주소 공간의 나머지 영역에 위치하며, **크기는 동적으로 확장**될 수 있다.    

---

### **프로세스의 상태**

현대의 컴퓨터에서는 프로세스를 처리할 때 5가지의 프로세스 상태 생명주기에 따라 프로그램을 처리한다.   

![](https://blog.kakaocdn.net/dn/nlRXS/btsjD9ZmaQb/gdFLLQctHIsew6kjzAkS20/img.png)

**① 프로세스 생성(new)**   

프로세스가 **생성된 상태**이다. 생성만 되었고, 아직 실행되기 위한 자원을 할당받지 못한 상태이다.    

**② 실행 가능(Ready)**   

프로세스가 **실행을 기다리는 상태**이다. 프로세스가 필요한 자원을 모두 할당받았으며, 실행을 위한 준비가 완료되었지만 CPU를 할당받지 못한 상태이다. 이 상태에서는 CPU를 할당받기 위해 스케줄링 대기열(Queue)에 들어가게 된다.    
 
**③ 실행 상태(Running)**   

프로세스가 CPU를 할당받아 실제로 **코드를 실행하는 상태**이다. 이 상태에서는 프로세스가 작업을 처리하고 결과를 만들어 낸다.   

**④ 대기(Blocked)**   

프로세스를 처리중에 작업 시간이 초과되거나 자원 사용을 위해 대기해야 하는 이벤트가 발생해서 **프로세스가 잠시 멈춘 상태**이다. 이 상태에서는 CPU를 사용하지 않는다. 특정 자원을 사용할 수 있을 때까지 실행을 멈추고, 다시 대기열(Ready Queue)로 들어가게 되며, 프로세스 처리 가능 상태가 되면 실행(Running) 상태로 변경한다.    

**⑤ 종료(Terminated, exit)**   

프로세스의 실행이 완료되어 **종료된 상태**이다. 이 상태에서는 할당된 자원이 해제되고, 프로세스의 메모리 공간은 운영체제에 반환된다.   

---

### **프로세스의 PC와 SP**

프로세스가 실제로 돌아가려면 PC(Program Counter)와 SP(Stack Pointer)가 필요하다.   

컴퓨터에서는 프로세스를 처리하기위한 2가지의 레지스터가 있다. 이 레지스터들이 PC와 SP이며, 프로세스의 실행 및 메모리 관리와 관련된 역할을 한다.   

**PC(Program Counter)**    

**-** PC는 **현재 실행 중인 명령어의 주소를 가리키는 레지스터**다.   

**-** 코드를 실행시키면 코드가 한 줄씩 내려가며 실행되는데, 프로세스는 한 줄을 처리 후 다음 실행할 코드가 어딘지 알려줘야 코드를 찾아서 실행할 수 있다. 이때, **다음 실행할 코드의 주소를 저장하는 레지스터가 PC이다.**    

**-** 프로세스는 명령어를 순차적으로 실행하면서 PC 값을 증가시켜서 다음에 실행할 명령어를 가리킨다.    

**-** PC는 프로그램의 흐름을 제어하는 역할을 한다. 프로세스가 명령어를 실행하다가 분기나 점프 명령어를 만나면 PC의 값을 분기된 주소로 변경하여 해당 명령어를 실행한다.    

**-** PC는 프로세스가 중단되거나 인터럽트(예외 상황)가 발생했을 때 현재 실행 중이던 명령어의 주소를 저장하고, 이후 다시 프로세스가 실행되었을 때 주소를 찾아가 재실행 시킬 수 있는 역할을 한다.    

**SP(Stack Pointer)**    

**-** SP는 **현재 실행 중인 프로세스의 스택(Stack)의 최상단을 가리키는 레지스터**이다.    

**-** 코드를 작성할 때, 재귀함수처럼 함수 안에 함수를 호출해야 하는 경우가 있다. 이럴 경우, 가장 최근에 호출한 함수 순서대로 Stack에 쌓이게 되는데, 가장 최근에 호출된 함수(=최상단 함수)의 위치를 알고 있으면, 어디까지 함수가 호출되어 있는지 프로세스가 알 수 있다.  

**-** 스택은 함수 호출이나 임시 데이터 저장 등을 위해 사용되는 메모리 영역으로, 후입선출(LIFO, Last-In-First-Out) 구조를 가지고 있다.  

**-** SP는 스택 프레임(Stack Frame, 스택 공간이란 뜻)의 시작 주소를 가리키며, 스택에 데이터를 저장하거나 불러올 때 사용된다.  

**-** 함수 호출 시에는 SP가 감소하여 스택에 새로운 스택 프레임(스택 공간)을 생성하고, 함수가 반환되면 SP가 증가하여 이전 스택 프레임으로 되돌아 간다.  

**-** SP는 프로세스의 스택 영역을 관리하고, 스택 오버플로우(Stack Overflow, 스택 영역 밖으로 메모리가 넘어가는 현상)와 같은 문제를 방지하기 위해 제한된 메모리 영역을 사용하는 등의 역할을 수행한다.

---

### **PCB(Process Control Block)**

프로그램이 실행되면 프로세스의 정보를 저장하는 별도의 공간이 따로 생기게 된다. 운영체제의 커널(Kernel) 또한 하나의 프로그램이므로 프로세스와 같이 정보를 저장할 수 있는 공간(stack, data, heap ...)이 생긴다. 이때, 커널의 데이터(Data) 영역에서는 각 프로세스의 상태, CPU 사용의 정보, 메모리 사용 정보 등 각종 자원을 관리하기 위해서 PCB라는 공간을 둔다.   

즉, PCB란 **운영체제가 프로세스를 관리하기 위해 사용하는 데이터 구조**이다.   PCB는 각 프로세스마다 유지되며, 해당 프로세스의 상태 정보와 제어 정보를 저장한다. **프로세스가 생성되면 운영체제는 PCB를 할당하고, 프로세스가 종료되면 해당 PCB를 해제한다.**   

위에서 설명한 PC와 SP 값이 이 PCB에 저장되고, 필요하면 PCB에서 불러와 코드 실행이 멈춰 있던 곳의 주소를 찾아가 다시 실행할 수 있게 해준다. 이 PCB가 존재하기 때문에, 우리의 프로그램이 잠시 중단된 상태에서 다시 실행할 때, 처음부터 되돌아가 실행하지 않고 실행을 이어서 처리할 수 있게 해준다.

우리가 흔히 볼 수 있는 **작업관리자** 창에선 현재 실행 중인 프로세스들을 모두 확인할 수 있다. 이때, 프로세스 고유 번호(PID), 프로세스들의 상태, 계정 정보, 사용 중인 메모리 할당 정보 등등 필요한 정보를 확인할 수 있는데, 이 정보들을 PCB에서 불러온다.

![](https://blog.kakaocdn.net/dn/nbrxi/btsjH1MvtlD/Bf8oLz0hLsGAh29cnfgUO0/img.png)

PCB에는 다음과 같은 정보들이 저장된다.   

**① 프로세스 상태(Process State)**  

프로세스의 현재 상태를 나타낸다. 예를 들면, 실행(Running), 준비(Ready), 대기(Waiting) 등의 상태 등이 있다. 이 상태 정보는 프로세스 스케줄링과 상호작용하여 프로세스의 실행을 관리한다.   

**② 프로그램 카운터(Program Counter, PC)**   

프로세스가 다음에 실행할 명령어(코드)의 주소를 가리키는 포인터이다. PC는 프로세스가 중단되었을 때 다시 시작할 위치를 알려주는 중요한 역할을 한다.   

**③ 레지스터(Registers)**   

프로세스가 현재 실행되는 동안 사용되는 레지스터 값들을 저장한다. 여기서 프로세스가 일시 중단되고 다시 실행 될 때 레지스터 값들을 복원하는 데 사용된다.   

**④ 스케줄링 정보(Scheduling Information)**   

프로세스의 우선순위, 할당 된 CPU 시간, 스케줄링 알고리즘과 관련된 정보 등 스케줄링에 필요한 정보를 포함한다.   

**⑤ 메모리 관리 정보(Memory Management Information)**   

프로세스가 사용하는 메모리 공간의 주소 범위, 페이지 테이블, 메모리 할당 정보 등과 같이 메모리 관리에 필요한 정보를 저장한다.    

**⑥ 입출력 상태(I/O state)**    

프로세스가 현재 사용 중인 입출력 장치와 관련된 정보를 포함한다. 예를 들어, 어떤 입출력 요청을 보내고 있는지, 어떤 파일을 열어두었는지 등의 정보를 저장한다.    


[출처](https://jerryjerryjerry.tistory.com/178)