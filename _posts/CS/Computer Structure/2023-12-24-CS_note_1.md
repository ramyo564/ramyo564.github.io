---
layout: single
title: " [CS 퀴즈] 오답노트 (1)"
categories: CS
tags:
  - CS
  - CS퀴즈
toc: true
toc_sticky: true
author_profile: false
sidebar:
---
# 주기억장치 & 보조기억장치

## 주기억장치
Primary Memory 또는 Main Memory

- 역할 : 주기억장치는 프로그램이나 데이터를 현재 사용 중일 때 일시적으로 저장하는 장소로, CPU가 직접 접근할 수 있는 고속의 저장장치
- 종류 : 
	- 레지스터 : CPU 내부에 위치하며 가장 빠르게 접근할 수 있는 기억장치 -> 명령어를 실행하거나 데이터를 처리하는 데 사용
		- 다른 주 기억장치에 비해 용량이 제한적이며 주로 실행중인 명령어나 중간 계산 결과를 저장하는데 사용함
	- RAM(Random Access Memory): 데이터를 임시로 저장하는데 사용되며, 전원이 꺼지면 데이터가 소멸한다. RAM은 읽기/쓰기 속도가 빠르지만 가격이 비싸다.
		- SRAM (Static Random Access Memory) : 정적인 레지스터 셀로 구성되어 있으며 각 셀은 플립플롭과 전달 게이트로 이루어져 있다. 데이터를 보유하는 동안에는 계속해서 전기적인 에너지를 소비한다.
		- DRAM : 동적인 셀로 구성되어 있으며 각 셀은 커패시터와 전달 트랜지스터로 이루어져 있으며 일정 시간마다 데이터를 새로고쳐야 한다.
		  
	- 캐시 메모리 : L1,L2,L3 캐시 등의 계층으로 구성되며 레지스터에 가까워 CPU와의 데이터 교환을 빠르게 한다. -> 주로 주 기억장치의 일부 데이터를 저장해서 빈번한 엑세스를 가속화하는데 사용한다.
	
- 특징 :
	- 휘발성 : 전원이 꺼지면 저장된 데이터도 사라짐
	- 읽기/쓰기 속도가 빠르며 CPU에 가까워 성능이 우수하다.



## 보조기억장치

- 역할 : 보조기억장치는 데이터를 장기적으로 저장하고, 전원이 꺼져도 데이터가 유지된다. 주로 대용량의 데이터 및 프로그램을 저장하는데 사용
- 종류 : 
	- HDD : 기계식 부품을 사용하여 데이터를 저장하며 대용량 저장 가능
	- SDD : 반도체 메모리를 사용하여 데이터를 저장하고 더 빠른 속도와 내구성을 갖고 있음
	- USB 플래시 드라이브 : 이동 가능하며 다양한 형태로 제공되는 보조기억장치
- 특징 : 
	- 비휘발성 : 전원이 꺼져도 데이터가 유지
	- 읽기/쓰기 속도는 주기억장치보다 느리지만 대용량 저장이 가능
	- 데이터의 장기 보존에 사용되며, 주로 운영체제, 응용프로그램,사용자파일 등을 저장하는데 사용됨



## bit

디지털 통신에서 사용되는 가장 기본적인 정보단위다.    
비트는 이진수 체계에서 0 또는 1의 두 가지 값을 나타내는 데 사용되며 비트는 정보를 저장하고 전송하는 데에 필요한 최소한의 단위다.    

- 8bit는 1byte   


**64bit architecture에서 워드의 길이는 64bit이다.**


1. **비트 (Bit):**
    - 비트는 0 또는 1의 두 가지 값 중 하나를 나타내는 이진 숫자의 가장 작은 단위다.
2. **워드 (Word):**
    - 워드는 컴퓨터 메모리에서 한 번에 처리되는 데이터의 크기를 나타낸다. 워드의 크기는 컴퓨터 아키텍처에 따라 다를 수 있다.
3. **아키텍처 (Architecture):**
    - 컴퓨터 아키텍처는 컴퓨터의 내부 구조 및 동작 방식을 정의하는 체계다. 주요 아키텍처 중에는 32비트 아키텍처와 64비트 아키텍처가 있다.

- 컴퓨터의 내부 구조에서 한 번에 처리되는 데이터 블록인 워드가 64비트 크기를 갖고 있으며 CPU가 한 번에 64비트의 데이터를 처리할 수 있다는 뜻    



**1바이트의 가장 큰 자리수를 담당하는 비트를 MSB라고 부른다.**   

바이트(Byte)는 일반적으로 8비트로 구성되어 있다. 각 비트의 위치에 따라서 비트를 가장 큰 자리수부터 가장 작은 자리수까지 나열할 수 있다. MSB(Most Significant Bit)는 가장 큰 자리수를 나타내는 비트를 가리키는 용어다.   

따라서 1바이트에서 MSB는 가장 좌측에 있는, 가장 큰 자리의 비트를 가리킨다. 예를 들어, 아래와 같이 표현할 수 있다:   

![](https://i.imgur.com/uHfmxRP.png)

**1nibble 은 4bit 다**

- 비트 : 0 또는 1의 두 가지 값을 가지는 이진수 쳬계에서의 최소한의 정보 단위
- 니블 : 니블은 4개의 비트로 이루어진 그룹 2^4 = 16 개의 가능한 값을 나타낼 수 있음
	- 00,01,10,11


## 16진수로 10진수 80을 바꾸면?

1. 80을 16으로 나눈다.
    - 80÷16=5, 나머지 080÷16=5, 나머지 0
2. 나누어진 몫을 다시 16으로 나눈다.
    - 5÷16=0, 나머지 55÷16=0, 나머지 5
3. 나머지를 16진수로 표현한다. 나머지가 10 이상일 경우에는 A, B, C, D, E, F로 표기한다.
    - 나머지가 10이므로, A16​
4. 나누어진 몫이 0이 될 때까지 이 과정을 반복한다.


## 00110101을 2의 보수를 이용해서 변환한다면?

1. **원래 이진수 표현:**
    - 주어진 이진수: 0011010100110101
2. **보수 구하기 (1의 보수):**
    - 각 비트를 반전시킨다 (0은 1로, 1은 0으로).
    - 1100101011001010
3. **1을 더하기:**
    - 1을 더한다.
    - 11001010+1=1100101111001010+1=11001011


### 보수란? 

일반적으로는 "1의 보수(One's Complement)"와 "2의 보수(Two's Complement)"가 사용된다.

1. **1의 보수 (One's Complement):**
    - 각 비트를 반전시킨 값을 사용한다다. 0은 1로, 1은 0으로 반전한다. 예를 들어, 5의 1의 보수는 0101의 반전인 1010 다.

2. **2의 보수 (Two's Complement):**
    - 1의 보수를 구하고, 그 결과에 1을 더한다. 이는 음수를 나타내는 데에 주로 사용된다. 예를 들어, 5의 2의 보수는 0101의 1의 보수인 1010에 1을 더한 1011다.

2의 보수를 사용하면 덧셈 연산이 더 간편해지며, 0을 나타내는 유일한 표현을 갖게 된다. 또한, 음수와 양수의 덧셈을 동일한 방식으로 수행할 수 있다.

이러한 보수의 개념은 주로 컴퓨터에서 음수를 표현하고 산술 연산을 수행하는 데에 사용된다.


## 주어진 부울 식 (BC' + A'D)(AB' + CD')을 부울 대수를 이용하여 간략화 시킨 결과는?

[계산기](https://www.boolean-algebra.com/)

![](https://i.imgur.com/eSdHLAO.png)


## 플립플롭의 종류

플립 플롭(Flip-Flop)은 디지털 회로에서 이진 상태를 저장하는데 사용되는 순차 논리 회로다. 플립 플롭은 여러 가지 종류가 있으며, 가장 흔한 종류로는 SR 플립 플롭, D 플립 플롭, JK 플립 플롭, T 플립 플롭이 있다.

1. **SR 플립 플롭 (Set-Reset Flip-Flop):**
    - SR 플립 플롭은 Set(S)과 Reset(R) 두 입력을 가지며, 특정 상태로 설정하거나 초기화할 수 있다. 하지만 S와 R 입력이 동시에 활성화되면 불확정한 동작이 발생할 수 있다.
      
2. **D 플립 플롭 (Data or Delay Flip-Flop):**
    - D 플립 플롭은 데이터 입력(D)을 받아서 저장한다. 이전의 저장된 상태에 상관없이 항상 입력 데이터를 저장한다.
      
3. **JK 플립 플롭:**
    - JK 플립 플롭은 J와 K라는 두 입력을 가지며, 입력에 따라서 다양한 동작을 할 수 있다. JK 플립 플롭은 SR 플립 플롭의 불확정한 상태를 해결하고, 다양한 동작 모드를 제공한다.
      
4. **T 플립 플롭 (Toggle Flip-Flop):**
    - T 플립 플롭은 Toggle을 나타내는 T 입력을 가지며, T 입력이 활성화되면 현재 상태를 반전시킨다. 이는 이진 카운터 등에서 사용될 수 있다.


## CPU의 구성요소

1. **제어 장치(Control Unit):**    
    - 명령어 해석, 실행, 그리고 다른 시스템 구성 요소와의 상호 작용을 담당한다. 명령어를 가져와 해석하고, 다음에 실행할 명령어의 주소를 결정한다.
      
2. **연산 장치(ALU - Arithmetic Logic Unit):**
    - 산술 및 논리 연산을 수행한다. 숫자 연산, 논리 비교, 증가 및 감소 등의 연산을 처리한다.
      
3. **레지스터(Register):**
    - 고속으로 접근 가능한 작은 저장 공간으로, 명령어나 데이터를 일시적으로 저장하는데 사용된다. 레지스터는 연산에 필요한 데이터를 임시로 보관하고 조작하는 데 사용된다.
      
4. **캐시 메모리(Cache Memory):**
    - 레지스터와 메인 메모리 사이에 위치하며, 주로 프로세서가 빠르게 접근할 수 있는 데이터 및 명령어를 저장한다. 캐시 메모리는 메인 메모리로부터 데이터를 가져오는 속도를 향상시키고 프로세서의 성능을 향상시킨다.
      
5. **시스템 버스(System Bus):**
    - CPU 내부의 각 구성 요소 간의 통신을 담당하는 버스 시스템이 있다. 주로 주소 버스, 데이터 버스, 제어 버스의 세 가지로 구성된다.
      
6. **마이크로프로그램 카운터(Microprogram Counter):**
    - 다음에 실행할 명령어의 주소를 가리키는 레지스터다. 명령어의 위치를 추적하여 다음에 수행할 명령어를 가져온다.
      
7. **마이크로명령 레지스터(Microinstruction Register):**
    - 현재 수행 중인 명령어의 세부 제어 신호를 저장하는 레지스터다.
      
8. **플래그 레지스터(Flag Register):**
    - 연산 결과에 대한 상태 정보를 저장하는 레지스터다. 예를 들어, 연산이 양수인지 음수인지, 0인지 아닌지를 나타내는 플래그를 저장한다.


이러한 구성 요소들이 함께 동작하여 CPU가 프로그램의 명령어를 해석하고 실행하는 데 필요한 모든 기능을 수행한다. **PC(Program Counter)와 MAR(Memory Address Register)** 는 주소 지정 및 메모리 관련 작업에 중요한 역할을 한다. PC는 다음에 실행할 명령어의 주소를 저장하고, MAR은 **메모리에서 데이터를 읽거나 쓸 때 사용하는 주소를 저장한다**
**MBR(Memory Buffer Register)** 메모리 버퍼 레지스터는 메모리로부터 읽거나 메모리에 쓰여진 **데이터를 일시적으로 저장하는 레지스터다**

### 각각의 레지스터 Register 다시 정리

1. **프로그램 카운터 (Program Counter - PC):**
    - **기능:** 다음에 실행할 명령어의 주소를 저장한다. 명령어를 순차적으로 실행하며, 각 명령어의 주소는 프로그램 카운터에 저장되어 다음에 실행될 명령어를 지시한다.
      
2. **명령어 레지스터 (Instruction Register - IR):**
    - **기능:** 현재 실행 중인 명령어를 저장한다. CPU는 명령어 레지스터에 저장된 명령어를 해석하고 실행한다.
      
3. **누산기 (Accumulator - ACC):**
    - **기능:** 산술 및 논리 연산의 결과를 저장한다. 대부분의 산술 명령어는 누산기에 있는 데이터를 활용하여 연산을 수행한다.
      
4. **메모리 주소 레지스터 (Memory Address Register - MAR):**
    - **기능:** 메모리에서 데이터를 읽거나 쓸 때 사용되는 주소를 저장한다. 메모리 주소 레지스터는 주로 주소 버스에 연결되어 메모리와 상호 작용한다.
      
5. **메모리 버퍼 레지스터 (Memory Buffer Register - MBR):**
    - **기능:** 메모리에서 읽은 데이터나 메모리에 쓰려는 데이터를 일시적으로 저장한다. 메모리 버퍼 레지스터는 데이터 버스에 연결되어 데이터 전송에 사용된다.
      
6. **상태 레지스터 (Status Register 또는 Flag Register):**
    - **기능:** 프로세서의 현재 상태를 나타낸다. 예를 들어, 산술 연산의 결과가 양수인지, 음수인지, 영인지를 나타내는 플래그들이 있다.
      
7. **마이크로프로그램 카운터 (Microprogram Counter - μPC):**
    - **기능:** 마이크로명령(Microinstruction)을 가져올 주소를 저장한다. 제어 장치가 다음에 가져올 마이크로명령의 주소를 지시한다.
      
8. **마이크로명령 레지스터 (Microinstruction Register - μIR):**
    - **기능:** 현재 실행 중인 마이크로명령을 저장한다. 컨트롤 유닛이 해당 명령어의 동작을 제어하는 데 사용된다.


1. **명령어 레지스터 (Instruction Register - IR):**
    - **기능:** 현재 실행 중인 명령어를 저장한다. 명령어 레지스터는 메모리에서 읽어온 명령어를 보유하고, 제어 유닛이 해당 명령어를 해석하고 실행하는 데 사용한다.
      
2. **일반 목적 레지스터 (General Purpose Register):**
    - **기능:** 여러 목적으로 사용될 수 있는 레지스터로, 산술 연산, 데이터 저장, 및 중간 결과 저장 등 다양한 목적으로 사용된다. 프로그래머가 임의의 값을 저장하거나 조작하기 위해 사용된다.
    - ALU와 연결되어 있지 않다.
      
3. **작업 레지스터 (Working Register):**
    - **기능:** 특정 작업을 수행하기 위해 사용되는 일시적인 데이터를 저장하는 레지스터다. 중간 결과나 계산에 사용되며, 계산이 완료되면 다른 레지스터로 전송될 수 있다.
    - ALU와 직접 연결되어 있다.


### MBR (Master Boot Record)

MBR은 "Master Boot Record"의 약자로, 컴퓨터의 부팅 프로세스를 초기화하고 부트로더를 찾아 실행하는 데 중요한 역할을 하는 데이터 구조다.

MBR에는 다음과 같은 주요 구성 요소가 포함된다:

1. **부트로더 (Bootloader):**
    - MBR의 가장 중요한 부분으로, 컴퓨터가 부팅될 때 실행되는 프로그램이다. 부트로더는 보통 하드 디스크의 특정 위치에 있는 운영체제(OS)의 부트 섹터를 찾아 실행한다.
      
2. **파티션 테이블 (Partition Table):**
    - 하드 디스크에 있는 파티션들의 정보를 담고 있다. 각 파티션의 시작과 끝 위치, 크기, 종류 등을 기록하여 운영체제가 해당 파티션을 인식할 수 있게 한다. MBR은 보통 4개의 파티션까지만 지원한다.
      
3. **시그니처 (Signature):**
    - MBR의 끝에는 2바이트의 시그니처가 있다. 이 시그니처는 MBR이 유효한 부트 섹터인지 확인하는 역할을 한다. 일반적으로 0xAA55로 지정되어 있다.

컴퓨터가 부팅될 때, BIOS(또는 UEFI)는 첫 번째 섹터(512바이트)를 읽어와 MBR을 메모리에 로드하고, 그 안에 있는 부트로더를 실행시킨다. 부트로더는 다시 특정 운영체제의 부트 섹터를 찾아서 해당 운영체제를 부팅한다.

더 최근에는 UEFI(Unified Extensible Firmware Interface)가 BIOS를 대체하는 추세이며, GPT(GUID Partition Table)가 MBR을 대체하기 시작하고 있다. GPT는 MBR보다 더 큰 파티션 지원과 신뢰성 강화를 제공한다.


## 레지스터 마이크로 연산의 종류 micro-operation

레지스터에서 수행되는 각각의 작은 단위의 동작을 레지스터 마이크로 연산(micro-operation)이라고 한다. 레지스터 마이크로 연산은 기본적으로 데이터를 이동하거나 조작하는데 사용된다. 다양한 종류의 레지스터 마이크로 연산이 있지다.

1. **데이터 전송 (Transfer):**
    - 데이터를 한 레지스터에서 다른 레지스터로 이동시키는 연산이다. 예를 들어, 레지스터 A의 내용을 레지스터 B로 전송하는 연산이 이에 해당한다.

2. **로드 (Load):**  
    - 외부에서 주어진 데이터를 레지스터에 적재하는 연산이다. 예를 들어, 메모리에서 데이터를 읽어와 레지스터에 로드하는 연산이 있다.
      
3. **스토어 (Store):**
    - 레지스터에 있는 데이터를 외부로 내보내는 연산이다. 예를 들어, 레지스터의 내용을 메모리에 저장하는 연산이 있다.
      
4. **덧셈 (Addition):**
    - 레지스터에 저장된 데이터에 상수나 다른 레지스터의 값을 더하는 연산이다.
      
5. **뺄셈 (Subtraction):**
    - 레지스터에 저장된 데이터에서 상수나 다른 레지스터의 값을 빼는 연산이다.
      
6. **논리 연산 (Logical Operations):**
    - AND, OR, XOR 등의 논리 연산을 수행하는 연산이다. 레지스터의 각 비트에 대해 이러한 연산을 수행할 수 있다.
      
7. **시프트 (Shift):**
    - 레지스터의 내용을 왼쪽이나 오른쪽으로 비트 단위로 이동시키는 연산이다.
      
8. **회전 (Rotate):**
    - 레지스터의 내용을 왼쪽이나 오른쪽으로 비트 단위로 회전시키는 연산이다.
      
9. **클리어 (Clear):**
    - 레지스터의 내용을 0으로 초기화하는 연산이다.

이러한 레지스터 마이크로 연산은 프로세서의 제어 유닛에서 조합되어 다양한 명령어의 실행을 가능케 한다. 아키텍처에 따라 지원되는 레지스터 마이크로 연산의 종류가 다를 수 있다.   

## ALU의 마이크로 연산

1. **덧셈 (Addition):**
    - 두 개의 이진수를 더하는 연산.
      
2. **뺄셈 (Subtraction):**
    - 두 개의 이진수를 빼는 연산. 덧셈과 부정(2의 보수)을 활용하여 수행될 수 있다.
      
3. **AND 연산 (Logical AND):**
    - 두 개의 비트에 대해 AND 연산을 수행하는 연산.
      
4. **OR 연산 (Logical OR):**
    - 두 개의 비트에 대해 OR 연산을 수행하는 연산.
      
5. **XOR 연산 (Logical XOR):**
    - 두 개의 비트에 대해 XOR(배타적 논리합) 연산을 수행하는 연산.
      
6. **부정 (NOT 연산):**
    - 입력된 비트의 값을 반전시키는 연산.
      
7. **이동 (Shift):**
    - 비트를 왼쪽이나 오른쪽으로 이동시키는 연산.
      
8. **회전 (Rotate):**
    - 비트를 왼쪽이나 오른쪽으로 회전시키는 연산.
      
9. **비교 (Comparison):**
    - 두 개의 값을 비교하여 결과를 나타내는 연산.
      
10. **셋팅 (Setting):**
    - 특정 조건이 충족되면 특정 플래그를 설정하는 연산.
      
11. **증가 (Increment - INC):**
    - 주로 레지스터나 메모리의 값을 1씩 증가시키는 연산.
      
12. **감소 (Decrement):**
    - 주로 레지스터나 메모리의 값을 1씩 감소시키는 연산.

## ALU 에 포함되는 마이크로 연산, 레지스터에서 수행되는 마이크로 연산

1. **ALU에 포함되는 마이크로 연산:**    
    - 이것은 주로 산술 및 논리 연산을 다루는데 중점을 둔다. ALU는 덧셈, 뺄셈, 논리 연산 등을 처리하는데 사용된다. 이러한 연산은 CPU에서 명령어 수행 중에 데이터 조작을 위해 사용된다.
      
2. **레지스터에서 수행되는 마이크로 연산:**
    - 이것은 주로 레지스터 간의 데이터 전송, 로드, 스토어, 산술 연산, 논리 연산, 시프트, 회전 등과 같은 작은 규모의 연산을 다룬다. 레지스터 마이크로 연산은 CPU 내부 레지스터 간의 조작 및 데이터 이동에 사용된다.

두 유형의 마이크로 연산은 CPU의 다른 부분에서 사용되며, 목적과 활용 범위가 다르다. ALU는 주로 산술 및 논리적인 계산을 수행하고, 레지스터에서 수행되는 마이크로 연산은 레지스터 간의 데이터 조작을 다룬다.


## CPU 디자인
### [CPU 디자인](https://afterdawncoding.tistory.com/23#CPU%20%EB%94%94%EC%9E%90%EC%9D%B8-1)

CPU 내에서 디바이스들 간의 상호 연결 방법

직접 연결 : 연결 복잡도가 장치 수의 제곱에 비례

버스 연결 : 가장 가성비 높은 연결 방식. 공통된 통신 채널을 통해 다양한 신호를 운반. 오늘날 PC가 널리 사용될 수 있도록 함.

![](https://blog.kakaocdn.net/dn/bwNDZ7/btrrh6gwblT/xjrkY5CntWdXdhhyLDNUdK/img.png)

직접 연결과 버스 연결

#### 버스를 통한 레지스터 상호 연결 예1 : 멀티 플렉서를 이용

멀티 플렉서는 여러 개의 입력 신호들 중에서 선별하여 버스에 신호를 보낼 수 있다.

![](https://blog.kakaocdn.net/dn/dP3OE1/btrrd6Ij2n9/RXi2tFvDxo79HHWA2F0720/img.png)

#### 버스를 통한 레지스터 상호 연결 예2 : 상태 버스 버퍼

(버퍼는 연산의 중간 결과값을 기억함)

멀티 플렉서처럼 신호를 선택할 수 있고, Enable값을 컨트롤 할 수 있다.

![](https://blog.kakaocdn.net/dn/7hC3d/btrrjA2e0WV/LU84Uv3NSMBGjOW5NUKMDk/img.png)

![](https://blog.kakaocdn.net/dn/9e1Gi/btrrlT1ic4q/7aOvQzzo2I4W7BKx6pObt0/img.png)

---

### [마이크로 연산과 ALU](https://afterdawncoding.tistory.com/23#%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%20%EC%97%B0%EC%82%B0%EA%B3%BC%20ALU-1)

레지스터에 저장된 데이터에 대해 수행되는 기본적인 연산(일반적인 사칙연산과는 다름)

레지스터 전송 마이크로 연산 : 레지스터 사이에서 이진 정보를 전송

산술 마이크로 연산 : 레지스터에 저장된 수치 데이터에 대한 산술연산

논리 마이크로 연산 : 레지스터에 저장된 비수치 데이터에 대해 비트 조작 연산을 수행

시프트 마이크로 연산 : 레지스터에 저장된 데이터에 대해 시프트 연산을 수행

시프트 마이크로 연산의 예

이진수 100 = 십진수 4

시프트 좌측 이동 -> 이진수 1000 = 십진수 8 (4x2)

시프트 우측 이동 -> 이진수 10 = 십진수 2 (4/2)

![](https://blog.kakaocdn.net/dn/b4j7jg/btrrmfcbkR2/CJQrjPeqQCKQTTb1zqbG5K/img.png)

### [산술 논리 장치(Arithmetic Logic Unit : ALU)](https://afterdawncoding.tistory.com/23#%EC%82%B0%EC%88%A0%20%EB%85%BC%EB%A6%AC%20%EC%9E%A5%EC%B9%98(Arithmetic%20Logic%20Unit%20%3A%20ALU)-1)

주로 정수 연산을 처리하나, 최근에는 부동 소수 연산까지 처리함

산술 연산 : 덧셈, 뺄셈, 곱셈, 나눗셈, 증가, 감소, 보수

논리 연산 : AND, OR, NOT, XOR, 시프트

![](https://blog.kakaocdn.net/dn/bf2YA7/btrrh4357c7/zJKSK7udn4H9gYgCyYkLG0/img.png)

왼쪽의 연산들이 산술 연산들이며, SUB의 ~B+1은 1의 보수화 시키고 1을 더한다는 뜻이므로 2의 보수와 같다.

![](https://blog.kakaocdn.net/dn/bzG5ZQ/btrrlTG2aAO/qM43KIGZgOyCYZ7bmgsKwK/img.png)

#### * MSB와 LSB

![](https://blog.kakaocdn.net/dn/vWPT8/btrrdYceeBR/efJAxASrXkz6Olb7ZTB7W0/img.png)


## ROR  연산 LSR 연산

 01100110에 ROR 연산을 한번, LSR 연산을 한 번씩 적용한다면
 
1. **ROR 연산 (오른쪽으로 비트 회전):**
    - 오른쪽으로 한 비트를 회전시키면 맨 오른쪽 비트는 맨 왼쪽으로 이동한다.
      
    `01100110 (원래 값) 00110011 (ROR 연산 결과)`
    
2. **LSR 연산 (논리 오른쪽 시프트):**
    - 오른쪽으로 한 비트를 시프트하면 맨 왼쪽은 0으로 채워진다.

    `00110011 (ROR 연산 결과) 00011001 (LSR 연산 결과)`
    

따라서 `01100110`에 ROR 연산을 한 번 적용한 결과는 `00110011`이며, 그 후에 LSR 연산을 한 번 더 적용한 결과는 `00011001`다.   


ROR(오른쪽으로 비트 회전)와 LSR(논리 오른쪽 시프트) 연산은 컴퓨터 아키텍처 및 비트 조작에서 다양한 용도로 활용된다. 몇 가지 일반적인 사용 사례는 다음과 같다:

1. **암호화 및 해시 함수:**
    - 데이터를 회전하거나 시프트하여 데이터의 비트를 임의로 섞거나 암호화하는 데 사용될 수 있다.
      
2. **순환 회로 (Circular Shift):**
    - 비트 회전은 순환 회로에서 사용될 수 있다. 순환 회로는 한 비트가 끝에서 다시 시작으로 돌아가면서 계산을 반복하는데 사용된다.
      
3. **데이터 정렬 및 조작:**
    - 특정 비트를 기준으로 데이터를 정렬하거나, 특정 비트를 이동하여 데이터를 적절히 조작하는 데 사용된다.
      
4. **플래그 조작:**
    - 프로그래밍에서 특정 플래그의 상태를 확인하거나 변경하는 데 활용될 수 있다.
      
5. **바이트 순서 변환:**
    - 데이터의 바이트 순서를 변환하는 데 사용될 수 있다.
      
6. **회전 연산의 수학적 응용:**
    - 회전 연산은 수학적인 연산에서도 유용하게 사용될 수 있다.

이러한 연산들은 비트 조작이나 데이터 변환에 유용하며, 특히 어셈블리어 프로그래밍이나 하드웨어 설계에서 빈번하게 사용될 수 있다.